# Predicate Logic as Programming Language

Kowalski analysis

## Intorduction
- Good UX Reece approves

## Syntax
- Basic stuff
- Bro why is the implies symbol facing the other way ðŸ’€

## Semantics
- How the program actually gets computed
- $m=0$ case? Makes sense now relax past Matei

## Factorial example
- Yo is this mini kanren???
- This is hella hype I like this a lot
- Church numerals be like
- Computation by contradiction ðŸ’€

## Append example
- Why is bro saying some proof procedures find a counterexample. Does that mean that some don't?

## Horn clauses
- We went over this already Zawg move along

## Procedure Invocation
- You can define and call functions breh

## Computation
- Racket trace be like (Fig. 1)
- Is this just bro formalizing the computation by contradiction thing he was talking about earlier?
- Only one procedure call at a time
- What is difference between top-down and bottom-up

## Non-determinism
- Bro I was literally thinking that
- Ok not specifically that...
- I don't fully understand what blud is waffling about with pattern matching
- That's what I was thinking (random procedure invocation)

## Input-output
- Ah formalizing the mini kanren shit (shit here is used as an endearing term as I love it!)
- Is Fig. 4 non-deterministic while still yielding the answer of $x:=0$?
- This is mini kanren

## Sequencing of procedure calls
- I feel like this is the meat of the paper which is really cool. Control language seems lame though. I feel like there has to be a way of mathematically proving the optimal procedure scheduling for any program. 

## Final thoughts
- I really really enjoyed this paper. I kinda wish it was longer tbh because the topic is really cool and I would've like to see my boy Kowalski go deeper into some of this. Very hype nonetheless.