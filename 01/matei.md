# Matei's thoughts

Hoare ðŸ’€

"f is an expression of a programming language without side effects but possibly containing x" - Hint at recursion?!?!?!

Axiom of Assignment: $P_0\{x:=f\}P$ - Beta reduction!?!?

Goofy ah implies symbol $\supset$ ðŸ’€

We don't even prove prgrams today because of woke

I want to go through the rigorous proof and understand what is going on

It would also be very interesting to see what kind of new program proving techniques are out there. Blud keeps talking about how annoying it is to prove programs and how people should make better techniques, so I wanna see what's out there.

ALGOL, FORTRAN, and COBOL ðŸ’€. Blud is ancient. Bro is the one from the past ðŸ’€. Bro thinks he is talking about the most current programming languages ðŸ’€. Bro thinks he is discussing cutting edge technology ðŸ’€.

Bro literally told programmers to design better programming languages ðŸ’€

## Actual Notes

Why prove programs?
- Reliability
    - Will my program always do what I want it to do
    - Instead of just testing edge cases I want to prove formally that my program works
- Documentation
    - The way to document is by noting down what your state looks like before and after a program. Hmmmmm that sounds awfully similar to another thing we were doing... Maybe we could write a proof of the program, and since those are so rigorous, we can be sure that it goes over exactly what the program is doing!!!
- Compatability
    - My program works on my computer but not shulin's!!! Waaaa waaaa waaa
    - OMG what if I wrote a proof about it where one of my axioms was a machine dependent statement. Now I know that it will work on all computer's that fit that axiom!

You can now also formally describe programming languages using these axioms. This way of defining languages can also be extremely helpful since nerds and normal people can understand it. Hype! Check [it](https://www.algol60.org/reports/algol60_rr.pdf?page=13) yo. Axioms allow you to leave things undefined as well which become defined later when you actually implement.